#!/bin/bash
# SPDX-License-Identifier: GPL-2.0-or-later
#
# Copyright (C) 2017-2024 TQ-Systems GmbH <oss@ew.tq-group.com>,
# D-82229 Seefeld, Germany.
# Author: Markus Niebel, Martin Schmiedel
#
# Description: build all machines in a layer with a given config
#
###############################################################################
set -e
set -C # noclobber

# TRAP SIGNALS
trap 'error_abort $LINENO' ERR

function error_abort () {
	echo "error at $1"
}

readonly SCRIPTNAME="${0}"
readonly SCRIPTPATH=$(dirname "$(readlink -f "${0}")")
readonly SCRIPT="$(basename "${0}")"

# depends on bitbake / poky version
readonly BITBAKE_GIT_MIRROR_PKG_EXTENSION="tar.gz"

. "${SCRIPTPATH}/utils"

usage() {
	cat <<END
Usage:

${SCRIPTNAME} <build-dir> [template] [--dryrun] [--debug]

<build-dir>: specifies the build directory location (required)
[template]: template bblayers.conf to use
[-h|--help]: print this message
[--dryrun=<yes|no>]: call bitbake in dry-run mode, default no
[--devel=<yes|no>]: allow development mode, default no, (use different auto.conf to disable CI features)
[--debug=<yes|no>]: print additional informations, default no
[--archive=<yes|no>]: synonym for deploy
[--deploy=<yes|no>]: en/disable deploy, default no
[--deploydir=<directory>]: deploy to this directory (only if --deploy=yes)
[--release=<yes|no>]: en/disable tarball generation, default no, implies deploy=yes
[--skipbitbake=<yes|no>]: don't call bitbake, default no

If the variable "LOCAL" is defined in environment of ${SCRIPT}, the
variables "DISTRO_LIST", "MACHINE_LIST" and "IMAGE_LIST" can be used
to define what is built. Otherwise the lists are calculated.
END
}

#
# write common part of build information
#
# (re)create the file, write generic header in Markdown
#
# $1 output file (file to create)
#
create_build_info () {
	local file="${1}"

	# create a file containing information about sources we built from
	cat > "${file}" <<END
# Build information

## Version info for BSP project

### Main project commit

\`\`\`
$(git log -1)
\`\`\`

### Submodules

\`\`\`
$(git submodule foreach --quiet 'echo "$name:\n\tURL: $(git remote get-url origin)\n\tREV: $(git log --format="%H" -1) $(git describe --all $(git log --format="%H" -1))"')
\`\`\`

END
}

#
# generate build info
#
# $1 output file (file to append)
# $2 bitbake distro
#
print_bitbake_build_info () {
	local file="${1}"
	local distro="${2}"

	cat >> "${file}" <<END

## Configuration info for BSP project

__DISTRO__: ${distro}

### Layer configuration

The following \`bblayers.conf\` template was used in this build:

\`\`\`
$(cat  "$(cat conf/templateconf.cfg)/bblayers.conf.sample")
\`\`\`

END
}

#
# generate machine info
#
# $1 output file (file to append)
# $1 machine name
#
print_bitbake_machine_info () {
	local file="${1}"
	local machine="${2}"

	cat >> "${file}" <<END

## Build target

__MACHINE__: ${machine}

END
}

#
# generate version and source info for a virtual package
#
# Query SRCREV and SRC_URI if there is a provider for the virtual package.
# output the information to the given file. Used for machine specific build
# information. The source must be under version control, e.g. git, to query SRCREV.
#
# $1 output file (file to append)
# $2 target - virtual target to query (e.g. kernel for virtual/kernel)
#
print_virtual_provider_info () {
	local recipe
	recipe=$(bitbake-getvar --quiet --value PREFERRED_PROVIDER_virtual/${2} 2>/dev/null)
	if [ -n "${recipe}" ] && ! [ "${recipe}" = "None" ]; then
		local srcrev
		local srcuri
		srcrev=$(bitbake-getvar --quiet --value --recipe "${recipe}" SRCREV 2>/dev/null)
		srcuri=$(bitbake-getvar --quiet --value --recipe "${recipe}" SRC_URI 2>/dev/null)
		cat >> "${1}" <<END

### virtual/${2}

__URI__:
\`\`\`
$(for uri in ${srcuri}; do echo "${uri}"; done)
\`\`\`
__COMMIT__:  ${srcrev}
END
	else
		cat >> "${1}" <<END

### virtual/${2}:

No source info available.

END
	fi
}

main () {
	local debug="no"
	local deploy="no"
	local develmode="no"
	local dryrun="no"
	local release="no"
	local skipbitbake="no"
	local build_dir=""
	local build_info_file=""
	local config="mainline"
	local deploydir=""
	local distros=""
	# machine specific packages to deploy, only needed if 'deploy="yes"'
	local -r extra_machine_pkg_for_deploy="kernel-dev kernel-dbg kernel-vmlinux"
	local machines=""
	local pos_params=""
	local stamp=""
	local top_dir=""

	# default
	deploydir="$(readlink -f ./deployment)"

	while (( "$#" )); do
		case "$1" in
		-h|--help )
			usage
			return 0
			;;
		--archive=* )
			deploy=${1#*=}
			shift
			;;
		--debug=* )
			debug=${1#*=}
			if [ "${debug}" = "yes" ]; then
				# To enable output from function 'debug' need to set variable
				# 'DEBUG' -  see sourced '${SCRIPTPATH}/utils'
				DEBUG="on"
			fi
			shift
			;;
		--dryrun=* )
			dryrun=${1#*=}
			shift
			;;
		--deploy=* )
			deploy=${1#*=}
			shift
			;;
		--deploydir=* )
			deploydir="$(readlink -f ${1#*=})"
			shift
			;;
		--devel=* )
			develmode=${1#*=}
			shift
			;;
		--release=* )
			release=${1#*=}
			shift
			;;
		--skipbitbake=* )
			skipbitbake=${1#*=}
			shift
			;;
		--*=|-*) # unsupported flags
			error_out "Error: Unsupported flag $1"
			exit 1
			;;
		*) # preserve positional arguments
			pos_params="$pos_params $1"
			shift
			;;
		esac
	done

	if ! is_gnu_grep; then
		return 1
	fi

	if [ "${dryrun}" = "yes" ]; then
		bitbake_args="--dry-run"
	fi

	if [ "${release}" = "yes" ] || [ "${deploy}" = "yes" ]; then
		if [ "${dryrun}" = "yes" ] || [ "${skipbitbake}" = "yes " ]; then
			info "Disabling archive/deploy in dry-run / skip-bitbake mode"
			release="no"
			deploy="no"
		fi
	fi

	if [ "${release}" = "yes" ]; then
		info "release/archive implies deploy"
		deploy="yes"
	fi

	# set positional arguments in their proper place
	eval set -- "$pos_params"

	if [ $# -lt 1 ]
	then
		usage
		exit 1
	fi

	build_dir="${1}"
	if [ -n "${2}" ]
	then
		config=${2}
	fi

	build_info_file="${deploydir}/${config}-build_info.md"
	top_dir="$(pwd)"
	distros="$(get_distros "${top_dir}/${DEFAULT_BUILD_CONFIG}" "${config}")"
	machines="$(get_machines "${top_dir}/${DEFAULT_BUILD_CONFIG}" "${config}")"
	stamp="$("${SCRIPTPATH}/git-revision-name.sh" "${YOCTO_VERSION}")"

	if [ "${deploy}" = "yes" ]
	then
		# cleanup any old deployment
		if [ -d "${deploydir}" ]; then
			rm -rf "${deploydir}"
		fi
		mkdir -p "${deploydir}"

		create_build_info "${build_info_file}"
	fi

	debug "Machines to build: ${machines}"
	debug "Distros to build: ${distros}"

	for distro in ${distros}
	do
		local images

		# GENERAL
		images=$(get_images "${top_dir}/${DEFAULT_BUILD_CONFIG}" "${distro}")
		debug "Images to build: ${images}"

		# source the real setup workhorse
		export EULA="y"
		export DISTRO=${distro}
		export MACHINE
		MACHINE=$(echo ${machines} | awk '{ print $1 }')

		# clean conf, to enforce a really clean configuration and to enable
		# incremental changes in the config using our template dir
		rm -rf "${build_dir}_${distro}/conf"

		# although DISTRO and MACHINE are exported, setup-environment
		# uses these variable mainly to set default in local.conf
		# afterwards they can be set again to iterate over all buildable
		# machines
		if ! . ./setup-environment "${build_dir}_${distro}" "${config}"
		then
			error_out "sourcing setup-environment failed"
		fi

		info "build images"
		#
		# config bitbake from autoconf template
		#
		if [ "${develmode}" = "no" ]
		then
			do_create_auto_conf "ci"
		else
			do_create_auto_conf
		fi

		if [ -n "${SSTATE_DIR}" ]; then
			# add SSTATE dir outside of builddir, optimize global builds
			assign_or_replace SSTATE_DIR "${SSTATE_DIR}" "=" conf/local.conf
		else
			info "env SSTATE_DIR empty, using local dir or add it to your site.conf / auto.conf"
		fi

		if [ -n "${DL_DIR}" ]; then
			# add DL_DIR dir outside of builddir, optimize global builds
			assign_or_replace DL_DIR "${DL_DIR}" "=" conf/local.conf

		else
			info "env DL_DIR empty, using local dir or add it to your site.conf / auto.conf"
		fi

		for img in ${images}
		do
			# now force bitbake to generate images for all targets ...
			for machine in ${machines}
			do
				# overwrite MACHINE
				export MACHINE=${machine}
				# create image for $MACHINE
				info "baking: ${machine} ${distro} ${img} ..."

				if [ "${skipbitbake}" = "no" ]
				then
					if ! bitbake ${bitbake_args} "${img}"
					then
						error_out "bitbake ${bitbake_args} ${img} for ${MACHINE} failed"
					fi
				fi
			done
		done
		if [ "${deploy}" = "yes" ]
		then
			local distro_codename

			# note: this depends on a selected distro
			distro_codename=$(bitbake-getvar -q --value DISTRO_CODENAME)

			for machine in ${machines}; do
				# export $MACHINE before query bitbake
				export MACHINE=${machine}
				local artifact_link_find_opt
				local artifactsdir
				local kernel_dtb
				local kimage
				local machine_archive
				local pkg_deploy_dir
				local pkg_type
				local yocto_machine_dir

				artifactsdir=$(bitbake-getvar -q --value DEPLOY_DIR_IMAGE)
				machine_archive=${machine}_${config}_${distro_codename}_${distro}_${stamp}
				# DEPLOY_DIR_<pkg> depends on PACKAGE_CLASSES, images are built from first type
				# package class names have naming convention 'package_<type>'
				pkg_type=$(bitbake-getvar --quiet --value PACKAGE_CLASSES | awk -F '_' '{ print toupper($2) }')
				pkg_deploy_dir=$(bitbake-getvar --quiet --value DEPLOY_DIR_${pkg_type})
				# replace dash with underscore for yocto (default) machine directory name
				yocto_machine_dir=${machine//-/_}
				info "archiving ${machine} ..."
				# we create some files in ${artifactsdir}, clean them before recreate
				rm -f "${artifactsdir}"/*.md
				rm -f "${artifactsdir}"/*.md5sum
				rm -f "${artifactsdir}/${machine_archive}.environment"
				# create a file containing md5sum of files
				get_md5sum "${artifactsdir}" > "${deploydir}/${machine_archive}.md5sum"
				cp "${deploydir}/${machine_archive}.md5sum" "${artifactsdir}/${machine_archive}.md5sum"
				bitbake --environment | grep ^[A-Z,a-z,0-9][^[:space:]]*=\" > "${artifactsdir}/${machine_archive}.environment"
				# use pregenerated build info
				cp "${build_info_file}" "${artifactsdir}/${machine_archive}.md"
				# enrich with machine specific information for some virtual packages
				print_bitbake_build_info "${artifactsdir}/${machine_archive}.md" "${distro}"
				print_bitbake_machine_info "${artifactsdir}/${machine_archive}.md" "${machine}"
				print_virtual_provider_info "${artifactsdir}/${machine_archive}.md" kernel
				print_virtual_provider_info "${artifactsdir}/${machine_archive}.md" bootloader
				# TODO:
				# 1) add more packages if needed
				# 2) we have different recipes and use different sources for TF-A / trusted-firmware-a
				# Should atf-imx / qoriq-atf etc. labeled as PREFERRED_PROVIDER? If yes, this should go upstream.
				# print_virtual_provider_info "${artifactsdir}/${machine_archive}.info" "trusted-firmware-a"

				# create image archive for $MACHINE, assume DEPLOY_DIR_IMAGE has ${MACHINE} as final part
				if [ "${release}" = "yes" ]
				then
					if ! tar -cvf ${deploydir}/${machine_archive}.BIN.tar.gz \
						-C "$(dirname "${artifactsdir}")" \
						"$(basename "${artifactsdir}")" --use-compress-program=pigz
					then
						error_out "archiving for ${machine} failed"
					fi
				fi

				# add some artifacts for automated testing, needed by name / pattern without
				# bitbake timestamp annotation etc. Copy the named links as file. Real files
				# will be copied after this.
				mkdir -p ${deploydir}/${machine}

				# options to find and copy links as artifacts for CI testing
				artifact_link_find_opt="-type l -readable"
				# deploy rootfs tar.gz image if existing. Use ${IMAGE_LINK_NAME} plus 'tar.gz'
				# to decouple bitbake / YP and our test jobs expecting rootfs artifacts as
				# '${image-recipe-name}-${machine}.tar.gz'
				for img in ${images}; do
					local image_name

					image_name=$(bitbake-getvar --recipe ${img} --quiet --value IMAGE_LINK_NAME)
					find "${artifactsdir}"  -maxdepth 1 -name "${image_name}.tar.gz" ${artifact_link_find_opt} \
						-exec cp --dereference "{}" "${deploydir}/${machine}/${img}-${machine}.tar.gz" \;
				done

				# deploy kernel device tree if existing
				kernel_dtb=$(bitbake-getvar --recipe virtual/kernel --quiet --value KERNEL_DEVICETREE)
				for dtb in ${kernel_dtb}; do
					find "${artifactsdir}"  -maxdepth 1 -name "$(basename ${dtb})" ${artifact_link_find_opt} \
						-exec cp "{}" "${deploydir}/${machine}/" \;
				done
				# deploy the kernel image if existing
				kimage=$(bitbake-getvar --recipe virtual/kernel --quiet --value KERNEL_IMAGETYPE)
				find "${artifactsdir}"  -maxdepth 1 -name "${kimage}" ${artifact_link_find_opt} \
					-exec cp "{}" "${deploydir}/${machine}/" \;

				# device tree and dev package, exact pattern for version depends on $pkg_type
				for pkg in ${extra_machine_pkg_for_deploy}; do
					find "${pkg_deploy_dir}/${yocto_machine_dir}" -maxdepth 1 -name "${pkg}-*" -readable \
						-exec cp "{}" "${deploydir}/${machine}/" \;
				done

				# copy rest of artifact files but do not override existing files which could be
				# needed for test
				find ${artifactsdir} -type f -exec cp --no-clobber "{}" ${deploydir}/${machine}/ \;
				
				# TODO: linking ${artifactsdir} to ${deploydir}/${machine} only works for fresh
				# checkout as used in a CI environment
			done
		fi

		cd "${top_dir}"
	done
	if [ "${release}" = "yes" ]
	then
		local licenses_src_path
		local archived_src_path

		# create licenses and mirror archive
		local archive_basename=${config}_${stamp}

		mkdir -p "${archive_basename}.LIC"
		# copy the file from licenses
		licenses_src_path=$(ls -d ${build_dir}_*/tmp*/deploy/licenses/*)
		for f in ${licenses_src_path}; do
			cp -r "${f}" "${archive_basename}.LIC";
		done

		tar -cvf "${archive_basename}.LIC.tar.gz" "${archive_basename}.LIC" --use-compress-program=pigz
		# do some cleanup
		rm -rf "${archive_basename}.LIC"

		mkdir -p "${archive_basename}.MIRROR.SRC"
		DL_DIR=$(bitbake-getvar -q --value DL_DIR)
		# query all archived sources, needs archiver class in config
		archived_src_path=$(ls -1 ${build_dir}_*/tmp*/deploy/sources/*/*/*)

		# copy the file from archived sources if it exists in DL_DIR
		for f in ${archived_src_path}; do
			local filename
			filename="${DL_DIR}/$(basename ${f})"
			if [ -e "${filename}" ]; then
				cp "${filename}" "${archive_basename}.MIRROR.SRC";
			else
				debug "$f has no counterpart ${filename}"
			fi
		done

		# we assume here that bitbake is configured to use shallow cloning
		# and that these packages use ${BITBAKE_GIT_MIRROR_PKG_EXTENSION} as extension
		find ${DL_DIR} -name gitshallow_*.${BITBAKE_GIT_MIRROR_PKG_EXTENSION} -exec cp "{}" "${archive_basename}.MIRROR.SRC/" \;
		find ${DL_DIR} -name gitsmshallow_*.${BITBAKE_GIT_MIRROR_PKG_EXTENSION} -exec cp "{}" "${archive_basename}.MIRROR.SRC/" \;

		tar -cvf "${archive_basename}.MIRROR.SRC.tar.gz" "${archive_basename}.MIRROR.SRC" --use-compress-program=pigz
		# do some cleanup
		rm -rf "${archive_basename}.MIRROR.SRC"
	fi
}

main "${@}"
